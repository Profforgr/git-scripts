#!/bin/sh
#
# An example hook script to blocks unannotated tags from entering.
# Called by git-receive-pack with arguments: refname sha1-old sha1-new
#
# To enable this hook, make this file executable by "chmod +x update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
#

# --- Set compiler and style_checker PATH

PATH=/opt/gnatpro/6.1.0w/bin:/opt/bin:$PATH
export PATH

# --- Set trac envrionment (root trac directory for this project)

PYTHON=/usr/bin/python
TRAC_ENV=/home/trac/rootenv/gtest

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "Usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --bool hooks.allowunannotated)
allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
allowdeletetag=$(git config --bool hooks.allowdeletetag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
if [ -z "$projectdesc" -o "$projectdesc" = "Unnamed repository; edit this file to name it for gitweb." ]; then
	echo "*** Project description file hasn't been set" >&2
	exit 1
fi

root=$(mktemp -d /tmp/git-update-hook-XXXXXX)
log=$root/log
tree=$root/diff-tree
frem=$root/files-removed
fadd=$root/files-added
fman=$root/manifest

# Set Style_Checker options

OWEB="-H -cP -cY -l256"

#  The copyright pattern to check
CPYR=""

#  Pathnames matching the regexp will be excluded from the test
EXCLUDE=""

SC_OPTS="-H -ign out -ign tmplt -ign sed -ign txt \
        -lang Ada -H -cP -cY -sp -gnat05 -lang TXML $OWEB \
        -lang XML $OWEB -lang HTML $OWEB -lang XSD $OWEB -lang CSS $OWEB"

# To be set with the name of the MANIFEST file if any, this script will check
# if an added or removed file is properly added or removed from MANIFEST.
MANIFEST=""

# Process each file

function check() {
   id=$2
   file=`basename $4`
   mode=$(echo $3 | cut -c1)

   #  Check if it is a file to ignore

   if [[ -n "$EXCLUDE" && `echo "$6" | grep --regexp="$EXCLUDE"` ]]; then
      return 0;
   fi

   #  skip deleted/renamed files

   if [[ "$mode" = "D" || "$mode" = "R" ]]; then
       echo $4 >> $frem
       return 0;
   fi

   git show $id > $root/$file

   #  If the MANIFEST keep it around

   if [[ "$4" = "$MANIFEST" ]]; then
       cp $root/$file $fman
   fi

   #  If a new file, record it

   if [[ "$mode" == "A" ]]; then
       echo $4 >> $fadd
   fi

   (cd $root; style_checker $SC_OPTS -n "$4" "$file" )
   res=$?
   rm -f $root/$file
   return $res
}

# Process the changeset

check_commit()
{
    git diff-tree -r "$oldrev" "$newrev" > $tree

    exit_status=0

    while read old_mode new_mode old_sha1 new_sha1 status name; do
        check $old_sha1 $new_sha1 $status $name 2>&1 >> $log
        if [[ $? != 0 ]]; then
	    echo
	    cat $log >&2
	    echo -e "For details run: git diff ${old_sha1:0:7} ${new_sha1:0:7}" >&2
	    echo
	    exit_status=1
        fi
    done < $tree

    #  Check for MANIFEST if needed

    if [[ -n "$MANIFEST" && -f $fadd ]]; then
	if [[ ! -f $fman ]]; then
	    echo ""
	    echo Files added, but $MANIFEST not updated, consider adding:
	    git diff-tree --name-only --diff-filter=A -r $oldrev $newrev
	    exit_status=1
	else
	    while read fadded
	    do
		grep --quiet "$fadded\$" $fman
		if [[ $? = 1 ]]; then
		    echo File $fadded added but missing in $MANIFEST
		    exit_status=1
		fi
	    done < $fadd
	fi
    fi

    if [[ -n "$MANIFEST" && -f $frem ]]; then
	if [[ ! -f $fman ]]; then
	    echo ""
	    echo Files removed, but $MANIFEST not updated, condider removing:
	    git diff-tree --name-only --diff-filter=D -r $oldrev $newrev
	    exit_status=1
	else
	    while read fremoved
	    do
		grep --quiet "$fremoved\$" $fman
		if [[ $? = 0 ]]; then
		    echo File $fremoved removed but still in $MANIFEST
		    exit_status=1
		fi
	    done < $frem
	fi
    fi

    LOG=$(git log -1 --pretty="%s%n%b" $newrev)

    # check for trac ticket

    if [ -d "$TRAC_ENV" ]; then
	$PYTHON /home/git/scripts/trac-pre-commit-hook "$TRAC_ENV" "$LOG"

	if [ $? = 1 ]; then
	    exit_status=1
	fi;
    fi

    rm -fr $root

    # --- Finished
    exit $exit_status
}

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
if [ "$newrev" = "0000000000000000000000000000000000000000" ]; then
	newrev_type=delete
else
	newrev_type=$(git-cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		;;
	refs/heads/*,commit)
		# branch
		check_commit
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0

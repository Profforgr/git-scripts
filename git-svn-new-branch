#! /bin/sh

USAGE='abort|branch-point|checkout|attach [--dry-run] URL [branch_name]'
LONG_USAGE='   Commands:

      abort        : to abort an import
      branch-point : return branch point svn revision
      checkout     : retrieve a new branch
      attach       : attach previously imported (see above) branch to
                     corresponding branch point.
   Options:

      URL          : the full url to subversion branch
      branch_name  : the name of the remote branch to use
                     (default is the name of the subversion branch)
                     the local branch name is prefixed with "svn-"
      --dry-run    : nothing will changed in the local Git repository

   A common usage is:

      $ git svn-new-branch checkout svn+ssh://server/svn/branches/relA
      $ git svn-new-branch attach svn+ssh://server/svn/branches/relA

   Before attaching, it is possible to check the branch-point that will be
   used to connect the branch history to the master:

      $ git svn-new-branch branch-point svn+ssh://server/svn/branches/relA
'

OPTIONS_SPEC=


exec_path=$(git --exec-path)
. $exec_path/git-sh-setup
require_work_tree
cd_to_toplevel
set_reflog_action svn-new-branch

# Get require_work_tree from git-rebase--interactive.sh
require_clean_work_tree () {
   # test if working tree is dirty
   git rev-parse --verify HEAD > /dev/null &&
   git update-index --ignore-submodules --refresh &&
   git diff-files --quiet --ignore-submodules &&
   git diff-index --cached --quiet HEAD --ignore-submodules -- ||
   die "Working tree is dirty"
}

abort () {
   echo $1
   if [ "$1" = "--dry-run" ]; then
      dryrun=echo
      echo "Restart without --dry-run if you want to execute"\
         "the following commands:"
   fi
   require_clean_work_tree
   head=$(grep HEAD .git/SVN_NEW_BRANCH | sed -e "s/HEAD: //")
   branch_name=$(grep BRANCH_NAME .git/SVN_NEW_BRANCH |
      sed -e s"/BRANCH_NAME: //")
   $dryrun git checkout $head
   $dryrun git update-ref -d refs/remotes/$branch_name
   $dryrun find .git -name "*_map*" -print -exec rm -f {} \;
   $dryrun git branch -D svn-$branch_name

}

get_new_branch () {
   # Verify HEAD
   head=$(git symbolic-ref -q HEAD) ||
   head=$(git rev-parse --verify HEAD) ||
   die "Bad HEAD - I need a HEAD"

   require_clean_work_tree

   rm -f .git/SVN_NEW_BRANCH
   echo HEAD: ${head#refs/heads/} >> .git/SVN_NEW_BRANCH

   if [ "$1" = "--dry-run" ]; then
      dryrun=True
      shift
   else
      dryrun=False
   fi

   URL=$1

   if [[ "$2" == "" ]]; then
       branch_name=$(basename $URL)
   else
       branch_name=$2
   fi

   echo BRANCH_NAME: $branch_name >> .git/SVN_NEW_BRANCH

   echo
   echo Track $URL on $branch_name
   echo Local branch : svn-$branch_name
   echo

   echo Check if local branches exist

   if [[ "$(git branch -r | grep $branch_name)" != "" ]]; then
       die Remote branch $branch_name already imported.
   fi

   if [[ "$(git branch | grep svn-$branch_name)" != "" ]]; then
       die Local branch svn-$branch_name already present.
   fi

   echo Check if remote branch exists

   svn list $URL > /dev/null 2>&1

   if [ $? = 1 ]; then
      die The given URL does not exists.
   fi

   if [ "$dryrun" != "True" ]; then
      git config svn-remote.svn-$branch_name.url $URL
      git config svn-remote.svn-$branch_name.fetch :refs/remotes/$branch_name

      echo Fetch branch data
      git svn fetch --no-follow-parent svn-$branch_name
      git branch --track svn-$branch_name $branch_name

      echo Only branch history has been fetched, consider using
      echo git svn-new-branch attach $URL $branch_name
      echo to attach the old history to the branch.
   fi
}

attach_branch () {
   if [ "$1" == "--dry-run" ]; then
      dryrun=True
      shift
   else
      dryrun=False
   fi

   URL=$1
   if [ "$2" = "" ]; then
       branch_name=$(basename $URL)
   else
       branch_name=$2
   fi

   echo Finding branch point
   rsvn=$(get_branch_point $URL)
   if [ "$rsvn" = "" ]; then
      die "Can not find branch point"
   fi

   echo Subversion branch point: $rsvn

   nrsvn=$(find_nearest_rev $rsvn)
   rgit=$(git svn find-rev r$nrsvn)
   # Run it twice to avoid the svn rebuilding .rev_map messages
   rgit=$(git svn find-rev r$nrsvn)

   if [ "$rgit" = "" ]; then
      die "Can not find corresponding Git rev !"
   fi

   echo Corresponding Git revision: $rgit
   echo

   git log $rgit^..$rgit | cat -

   if [ "$dryrun" == "True" ]; then
      echo
      echo
      echo $ git filter-branch -f --tag-name-filter cat \\
      echo "   "--parent-filter \"sed -e 's/^$/-p $rgit/'\" \\
      echo "   svn-$branch_name"
      echo $ git reset --hard svn-$branch_name
      echo $ git update-ref refs/remotes/$branch_name svn-$branch_name
      echo $ find .git -name "*_map*" -print -exec rm -f {} \;
      echo $ git svn rebase
      echo
   else
      echo Checkout local branch
      git checkout svn-$branch_name
      (
         git filter-branch -f --tag-name-filter cat \
            --parent-filter "sed -e 's/^$/-p $rgit/'" svn-$branch_name &&
         git reset --hard svn-$branch_name &&
         git update-ref refs/remotes/$branch_name svn-$branch_name &&
         find .git -name "*_map*" -print -exec rm -f {} \; &&
         git svn rebase
      ) || die "Failed ! Use --abort to revert all changes"

   fi
}

get_branch_point () {
   branch=$1
   rev=$(svn log --verbose --stop-on-copy $branch | grep '(from' |
      grep -E -o ":([0-9]+)" | cut -c2- | tail -1)
   echo $rev
}

find_nearest_rev () {
   rev=$1
   nrev=$(
      (
         echo $rev;
         git svn log --oneline | grep -o -E 'r[0-9]+' | cut -c2-
      ) | sort -n | grep -E "^$rev" -B1 | head -1)
   echo $nrev
}

[ "$#" == "0" ] && usage && exit 1;

while [ "$#" != "0" ]; do
   case $1 in
      -h|*help)
         usage;;
      *abort)
         shift
         abort $@;
         exit $?
         ;;
      *branch-point)
         shift
         test $1 != "" && get_branch_point $@
         ;;
      *attach)
         shift
         test $1 != "" && attach_branch $@
         ;;
      *find-nearest-rev)
         shift
         test $1 != "" && find_nearest_rev $@
         ;;
      *checkout)
         shift
         test $1 != "" && get_new_branch $@;;
      *)
         shift;;
   esac
done

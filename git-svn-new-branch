#! /bin/sh

USAGE='abort|branch-point|attach|checkout [--dry-run] URL [branch_name]'
LONG_USAGE='URL is full url to subversion branch
branch_name is the name of the branch to use locally
   (optional, in this case use subversion branch name)
'

OPTIONS_SPEC=


exec_path=$(git --exec-path)
. $exec_path/git-sh-setup
require_work_tree
cd_to_toplevel
set_reflog_action svn-new-branch

# Get require_work_tree from git-rebase--interactive.sh
require_clean_work_tree () {
   # test if working tree is dirty
   git rev-parse --verify HEAD > /dev/null &&
   git update-index --ignore-submodules --refresh &&
   git diff-files --quiet --ignore-submodules &&
   git diff-index --cached --quiet HEAD --ignore-submodules -- ||
   die "Working tree is dirty"
}

abort () {
   require_clean_work_tree
   head=$(grep HEAD .git/SVN_NEW_BRANCH | sed -e "s/HEAD: //")
   branch_name=$(grep BRANCH_NAME .git/SVN_NEW_BRANCH |
      sed -e s"/BRANCH_NAME: //")
   git checkout $head
   git update-ref -d refs/remotes/$branch_name
   find .git -name "*_map*" -print -exec rm -f {} \;
   git branch -D svn-$branch_name

}

get_new_branch () {
   # Verify HEAD
   head=$(git symbolic-ref -q HEAD) ||
   head=$(git rev-parse --verify HEAD) ||
   die "Bad HEAD - I need a HEAD"

   require_clean_work_tree

   rm -f .git/SVN_NEW_BRANCH
   echo HEAD: ${head#refs/heads/} >> .git/SVN_NEW_BRANCH

   if [ "$1" = "--dry-run" ]; then
      dryrun=True
      shift
   fi

   URL=$1

   if [[ "$2" == "" ]]; then
       branch_name=$(basename $URL)
   else
       branch_name=$2
   fi

   echo BRANCH_NAME: $branch_name >> .git/SVN_NEW_BRANCH

   echo
   echo Track $URL on $branch_name
   echo Local branch : svn-$branch_name
   echo

   echo Check if local branches exist

   if [[ "$(git branch -r | grep $branch_name)" != "" ]]; then
       die Remote branch $branch_name already imported.
   fi

   if [[ "$(git branch | grep svn-$branch_name)" != "" ]]; then
       die Local branch svn-$branch_name already present.
   fi

   echo Check if remote branch exists

   svn list $URL > /dev/null 2>&1

   if [ $? = 1 ]; then
      die The given URL does not exists.
   fi

   git config svn-remote.svn-$branch_name.url $URL
   git config svn-remote.svn-$branch_name.fetch :refs/remotes/$branch_name

   echo Fetch branch data
   git svn fetch --no-follow-parent svn-$branch_name
   git branch --track svn-$branch_name $branch_name

   echo Only branch history has been fetched, consider using
   echo git svn-new-branch attach URL
   echo to attach the old history to the branch.

}

attach_branch () {
   URL=$1
   if [ "$2" = "" ]; then
       branch_name=$(basename $URL)
   else
       branch_name=$2
   fi

   echo Finding branch point
   rsvn=$(get_branch_point $URL)
   if [ "$rsvn" = "" ]; then
      die "Can not find branch point"
   fi

   echo Subversion branch point: $rsvn

   nrsvn=$(find_nearest_rev $rsvn)
   rgit=$(git svn find-rev r$nrsvn)
   # Run it twice to avoid the svn rebuilding .rev_map messages
   rgit=$(git svn find-rev r$nrsvn)

   if [ "$rgit" = "" ]; then
      die "Can not find corresponding Git rev !"
   fi

   echo Corresponding Git revision: $rgit
   echo

   git log $rgit^..$rgit | cat -

   if test $force = 0
   then
      echo
      echo
      echo $ git filter-branch -f --tag-name-filter cat \\
      echo "   "--parent-filter \"sed -e 's/^$/-p $rgit/'\" \\
      echo "   svn-$branch_name"
      echo $ git reset --hard svn-$branch_name
      echo $ git update-ref refs/remotes/$branch_name svn-$branch_name
      echo $ find .git -name "*_map*" -print -exec rm -f {} \;
      echo $ git svn rebase
      echo
   else
      echo Checkout local branch
      git checkout svn-$branch_name
      (
         git filter-branch -f --tag-name-filter cat \
            --parent-filter "sed -e 's/^$/-p $rgit/'" svn-$branch_name &&
         git reset --hard svn-$branch_name &&
         git update-ref refs/remotes/$branch_name svn-$branch_name &&
         find .git -name "*_map*" -print -exec rm -f {} \; &&
         git svn rebase
      ) || die "Failed ! Use --abort to revert all changes"

   fi
}

get_branch_point () {
   branch=$1
   rev=$(svn log --verbose --stop-on-copy $branch | grep '(from' |
      grep -E -o ":([0-9]+)" | cut -c2- | tail -1)
   echo $rev
}

find_nearest_rev () {
   rev=$1
   nrev=$(
      (
         echo r$rev;
         git svn log --oneline | grep -o -E 'r[0-9]+'
      ) | sort | grep r$rev -B1 | head -1 | cut -c2-)
   echo $nrev
}

while [ "$#" != "0" ]; do
   case $1 in
      -h|*help)
         usage;;
      *abort)
         abort;
         exit $?
         ;;
      *branch-point)
         shift
         test $1 != "" && get_branch_point $@
         ;;
      *attach)
         shift
         test $1 != "" && attach_branch $@
         ;;
      *find-nearest-rev)
         shift
         test $1 != "" && find_nearest_rev $@
         ;;
      *checkout)
         shift
         test $1 != "" && get_new_branch $@;;
      *)
         shift;;
   esac
done
